#!/usr/bin/env ruby

# install graphviz (https://graphviz.org/download/)
# install ruby 2.5 with devkit -- if not already done 
# 'gem install bundler' -- if not already done 
# 'bundle install' -- if not already done

# The graphviz executable should be in your path.
# If not, try uncommenting and updating the following:
# ENV["PATH"] = ENV["PATH"].split(";").push('C:\Program Files (x86)\Graphviz2.38\bin').join(";")

# For now, if you want to use a randomly generated map
# with Klank, I would suggest something like the following:
# 1) generate a rand map (map_###.png)
# 2) send it out via Teams, Zoom, etc.
# 3) let everyone review it, and agree it on
# 4) copy the map_###.yml to a slot for the game server to use and restart the server.
#
# You should definitely review any map generated as sometimes
# closed loops can be generated that can only accessed via 'teleport'.
# Additionally, the map layout generated by graphvbiz can 
# sometimes be a little confusing (even for valid maps.)


# make sure we have and are using the gem/versions from gemfile
require 'rubygems'
require 'bundler/setup'

# require any needed gems
require 'yaml'

# these are the possible numbers of ranks (floor) above and below ground
ABOVE_RANKS_RANGE = [3,4]
BELOW_RANKS_RANGE = [4,5]
# when a path between rooms is generated, these are the 
# possible attack/move value distrubutions
ATTACK_RANGE = [0,0,0,0,1,2]
MOVE_RANGE = [1,1,1,2]

# This returns true if the room_num is 'invalid' or has already
# been used for something else.
# Set cc_ok to false to ignore crystal caves (heals, minor, major, artifacts can be in cc).
# Set store_ok to false to ignore stores (minor, major, artifacts can be in stores).
def room_used(map, room_num, cc_ok = true, store_ok = true)
	max_room = map['rooms'].keys.max()
	used =  (room_num < 2) ||  # nothing in start room!
			(room_num > max_room) ||  # nothing past end room!
			(map['rooms'][room_num]['crystal-cave'] && cc_ok) ||
			(map['rooms'][room_num]['store'] && store_ok) ||
			(map['rooms'][room_num]['major-secrets'] > 0) ||
			(map['rooms'][room_num]['minor-secrets'] > 0) ||
			(map['rooms'][room_num]['monkey-idols'] > 0) ||
			(map['rooms'][room_num]['heal'] > 0) ||
			(map['rooms'][room_num]['artifact'] > 0)
	return used
end

# return count of paths in for room_num
def paths_in(map, room_num)
	count = 0
	keys = map['paths'].keys
		keys.each do |key|
		key =~ /^(\d+)-(\d+)$/
		n1, n2 = $1.to_i, $2.to_i
		if map['paths'][key]['one-way'] 
			if (n2 == room_num)
				count += 1
			end
		elsif ((n1 == room_num) || (n2 == room_num))
			count += 1
		end
	end
	return count
end

# return count of paths out for room_num
def paths_out(map, room_num)
	count = 0
	keys = map['paths'].keys
		keys.each do |key|
		key =~ /^(\d+)-(\d+)$/
		n1, n2 = $1.to_i, $2.to_i
		if map['paths'][key]['one-way'] 
			if (n1 == room_num)
				count += 1
			end
		elsif ((n1 == room_num) || (n2 == room_num))
			count += 1
		end
	end
	return count
end

# add a path between rooms s and e
def add_path(map, s, e, move = MOVE_RANGE.sample(), atk = ATTACK_RANGE.sample())
	# delete any old paths (in either direction)
	key = "#{e}-#{s}"
	map['paths'].delete(key)
	key = "#{s}-#{e}"
	map['paths'].delete(key)

	# if in the depths, add lock based on path value
	val = ((map['rooms'][s]['artifact'] + map['rooms'][e]['artifact'] + 
	       (room_used(map, s) ? 5 : 0) + (room_used(map, e) ? 5 : 0)) / 13).to_i
	locked = (s >= (map['depths'] / 1.5)) && (rand(1..(7 - val)) == 1)

	# if after first few rooms, make 1 in 4 paths one-way
	# or if path to monkey-idol room
	idols = map['rooms'][s]['monkey-idols'] + map['rooms'][e]['monkey-idols']
	one_way = false
	if (idols > 0) || ((s > 4) && (rand(1..4) == 1))
		if (rand(1..2) == 1)
			key = "#{e}-#{s}"
		end
		one_way = true
	end

	map['paths'][key] = {
		'move' => move,
		'attack' => atk,
		'locked' => locked,
		'one-way' => one_way
	}

	return key
end

module KlankMapGen
	require_relative 'map_graph.rb'

	#####################
	# generate images for our two base maps
	#####################
	map_file = 'map1.yml'
	map1 = Map.new(map_file, true, false)  # use a dark color scheme and no images
	map1.generate_map_graph()
	puts "generated graph for #{map_file}"

	map_file = 'map2.yml'
	map2 = Map.new(map_file)  # use light color scheme and no images
	map2.generate_map_graph()
	puts "generated graph for #{map_file}"

	#####################
	# now try generating a "random" map
	#####################

	seed = Time.now.to_i
	# tbd ksh !!! set fixed seed to debug a map
	# seed = 1603381149
	srand(seed)

	rand_map = { }
	room_num = 0

	rand_map['description'] = "This is a random map from seed #{seed}."
	rand_map['depths'] = 0
	rand_map['rooms'] = {}
	rand_map['paths'] = {}

	# rank 1/room 1 reserved for start room
	above_ranks = ABOVE_RANKS_RANGE.sample()
	above_step = rand(4..5)
	above_count = above_step * above_ranks  # not including room 1
	below_ranks = BELOW_RANKS_RANGE.sample()
	below_step = rand(5..6)
	below_count = below_step * below_ranks
	total_count = 1 + above_count + below_count  # includes room 1
	total_ranks = 1 + above_ranks + below_ranks  # includes rank 1

	rand_map['depths'] = 1 + above_count + 1  # which room depths start on

	# generate all the rooms empty
	(1..total_count).each do |room_num|
		rand_map['rooms'][room_num] = {
			'major-secrets' => 0,
			'minor-secrets' => 0,
			'monkey-idols' => 0,
			'heal' => 0,
			'artifact' => 0,
			'crystal-cave' => false,
			'store' => false
		}.merge(rand_map['rooms'][room_num] || {})
	end

	# make some rooms crystal caves (avg 1 per rank)
	(1..total_ranks).each do |i|
		loop do
			room_num = rand(2..total_count)
			break if !room_used(rand_map, room_num)
		end
		rand_map['rooms'][room_num]['crystal-cave'] = true
	end    

	# make 4 rooms stores
	(1..4).each do |i|
		# we want these to tend to be toward middle of board
		loop do
			room_num = (total_count / 2) + (rand(0..rand(1..total_count/2)) * [-1,1].sample())
			break if !room_used(rand_map, room_num)
		end
		rand_map['rooms'][room_num]['store'] = true
	end    

	# 7 rooms in the depths should have artifacts
	[ 30, 25, 20, 15, 10 , 7, 5 ].each_with_index do |artifact, i|
		# we want these to tend to be especially 'deeper'
		limit = 1000
		loop do
			limit -= 1
			room_num = 1 + above_count + below_count - rand(0..rand(0..rand(0..below_count))) - (i*3)
			# NB artifacts can be in crystal caves and stores
			break if (limit <= 0) || (!room_used(rand_map, room_num, false, false) && (room_num > (1 + above_count)))
		end
		rand_map['rooms'][room_num]['artifact'] = artifact
	end

	# make 1-2 heal rooms (more likely 2 heal rooms)
	num_heal_rooms = [1,2,2].sample()
	(1..num_heal_rooms).each do |i|
		# we want these to tend to be 'deeper'
		loop do
			room_num = total_count - rand(0..rand(0..total_count-1))
			# NB heal rooms can be in crystal caves
			break if !room_used(rand_map, room_num, false)
		end
		rand_map['rooms'][room_num]['heal'] = 1
	end    

	# make a monkey idol room in the depths
	loop do
		room_num = 1 + above_count + rand(1..below_count)
		break if !room_used(rand_map, room_num)
	end
	rand_map['rooms'][room_num]['monkey-idols'] = 3

	# 9 rooms should have 1 major secret
	(1..9).each do |i|
		loop do
			# want these to tend to be deeper
			room_num = rand(2..total_count) + (i*1.5).to_i
			# NB major secrets can be in crystal caves and stores
			break if !room_used(rand_map, room_num, false, false)
		end
		rand_map['rooms'][room_num]['major-secrets'] = 1
	end    

	# 9 rooms should have 2 minor secrets	
	(1..9).each do |i|
		loop do
			# want these to tend to be shallower
			room_num = rand(2..total_count) - (i*1.5).to_i
			# NB minor secrets can be in crystal caves and stores
			break if !room_used(rand_map, room_num, false, false)
		end
		rand_map['rooms'][room_num]['minor-secrets'] = 2
	end    

	# room 1 always connected to room 2
	add_path(rand_map, 1, 2, 1, 0)

	# one rank should have a wrap around path
	wrap_rank = rand(2..total_ranks)
	(2..total_ranks).each do |rank|

		# figure out room start/end for this rank
		if (rank <= (1 + above_ranks))
			step = above_step
			room_start = 1 + (rank - 2) * above_step + 1
			room_end = room_start + above_step - 1
		else
			step = below_step
			room_start = 1 + above_count + (rank - above_ranks - 2) * below_step + 1
			room_end = room_start + below_step - 1
		end
		# puts "#{rank}, #{step}, #{room_start}, #{room_end}"

		# wrap rank
		if (rank == wrap_rank)
			key = add_path(rand_map, room_start, room_end, 1, 0)
			# puts "wrap #{key} path"
		end

		# add LR (left-right) paths for this rank
		skipped = false
		(room_start..room_end-1).each do |room_num|
			# after first rank, skip 1 in 6 LR paths, but no more than 1 per rank
			if !skipped && (room_num > above_step) && (rand(1..6) == 1)
				skipped = true
			else
				add_path(rand_map, room_num, room_num+1)
			end
		end
	
		# add UD (up-down) paths for this rank
		if (rank < total_ranks)
			(room_start..room_end).each do |room_num|
				if true && (rand(1..8) == 1) && ((room_num == room_start) || (room_num == room_end))
					# make it a slide going two ranks
					e = room_num + (2 * step)
					e += (below_step - above_step) if (room_num < (1 + above_count)) && (e > (1 + above_count + 1))
					if (e <= total_count)
						key = add_path(rand_map, room_num, e)
						rand_map['paths'][key]['one-way'] = true
						# puts "slide #{key} path"
					end
				else
					e = room_num + step + [-1,0,1].sample()
					e += 2 if (e <= room_end)
					e -= 2 if (e > (room_end + step))
					if (e > room_end) && (e <= (room_end + step))
						add_path(rand_map, room_num, e)
					end
				end
			end
		end

	end

	# check rooms for ones with no paths in or no paths out
	# tbd ksh !!! this really should check that room can reach room 1
	added = true
	while (added)
		added = false
		(1..total_count).each do |room_num|
			if (paths_in(rand_map, room_num) < 1) || (paths_out(rand_map, room_num) < 1)		
				# try to add one
				e = (room_num > (below_step * 2)) ? (room_num - below_step) : (room_num + below_step)
				key = add_path(rand_map, room_num, e)
				# puts "no paths in/out, adding #{key}"
				added = true
			end
		end
	end

	# make high artifact value rooms a little harder to get to
	(1..total_count).each do |room_num|
		if (rand_map['rooms'][room_num]['artifact'] > 20)
			removed = false
			keys = rand_map['paths'].keys
			keys.each do |key|
				key =~ /^(\d+)-(\d+)$/
				n1, n2 = $1.to_i, $2.to_i
				if ((n1 == room_num) || (n2 == room_num))
					n2 = (n1 == room_num) ? n2 : n1  # set n2 to the "other" room
					# if more than 1 paths in, remove 1
					if (!removed && (paths_in(rand_map, room_num) > 1) && (paths_out(rand_map, n2) > 1))
						# puts "removing #{key} path"
						removed = true
						rand_map['paths'].delete(key)
					elsif (paths_in(rand_map, room_num) == 1)
						# if only one path in, lock it
						# puts "locking #{key} path"
						rand_map['paths'][key]['locked'] = true
					else
						# for all others, 1 of 2 things: make it locked or A2M2
						# puts "hardening #{key} path"
						if (rand(1..2) == 1)
							rand_map['paths'][key]['move'] = 2
							rand_map['paths'][key]['attack'] = 2
						else
							rand_map['paths'][key]['locked'] = true
						end
					end
				end
			end
		end
	end

	# now write out yml and image files
	map_file = "map_#{seed}.yml"
	File.open(map_file, 'w') { |file| file.write(rand_map.to_yaml) }
	map3 = Map.new(map_file, true, true)  # use dark color scheme and images
	map3.generate_map_graph()
	puts "generated graph for #{map_file}"

	puts "done...\n"
end